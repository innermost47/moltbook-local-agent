<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Agent Debugger - Live Feed</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"
    />
    <link rel="icon" type="image/x-icon" href="/assets/favicon.ico" />
    <link href="/assets/style.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  </head>
  <body>
    <!-- Matrix Rain Canvas -->
    <canvas id="matrix-rain"></canvas>

    <div class="header">
      <h1>Live Debug Feed</h1>
      <div id="status">
        <span class="status-dot"></span> Auto-syncing:
        <span id="last-update">--</span>
      </div>
    </div>
    <div class="container">
      <div id="logs"></div>
    </div>

    <script>
      /* ==============================
         MATRIX RAIN EFFECT
         ============================== */
      const canvas = document.getElementById("matrix-rain");
      const ctx = canvas.getContext("2d");

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      const matrixChars =
        "ã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã‚«ã‚­ã‚¯ã‚±ã‚³ã‚µã‚·ã‚¹ã‚»ã‚½ã‚¿ãƒãƒ„ãƒ†ãƒˆãƒŠãƒ‹ãƒŒãƒãƒãƒãƒ’ãƒ•ãƒ˜ãƒ›ãƒãƒŸãƒ ãƒ¡ãƒ¢ãƒ¤ãƒ¦ãƒ¨ãƒ©ãƒªãƒ«ãƒ¬ãƒ­ãƒ¯ãƒ²ãƒ³0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ{}[]<>/\\|=+-*&^%$#@!~";
      const fontSize = 14;
      let columns = Math.floor(canvas.width / fontSize);
      let drops = Array(columns).fill(1);

      // Randomize initial drop positions for a more organic start
      for (let i = 0; i < drops.length; i++) {
        drops[i] = Math.floor(Math.random() * -50);
      }

      function drawMatrix() {
        // Semi-transparent black to create trail effect
        ctx.fillStyle = "rgba(13, 17, 23, 0.06)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.font = fontSize + "px 'Fira Code', 'IBM Plex Mono', monospace";

        for (let i = 0; i < drops.length; i++) {
          const char =
            matrixChars[Math.floor(Math.random() * matrixChars.length)];
          const x = i * fontSize;
          const y = drops[i] * fontSize;

          // Brighter head character
          if (Math.random() > 0.7) {
            ctx.fillStyle = "#afffaf";
            ctx.shadowColor = "#00ff41";
            ctx.shadowBlur = 8;
          } else {
            // Varying green shades for depth
            const alpha = 0.15 + Math.random() * 0.25;
            ctx.fillStyle = `rgba(0, 255, 65, ${alpha})`;
            ctx.shadowColor = "transparent";
            ctx.shadowBlur = 0;
          }

          ctx.fillText(char, x, y);
          ctx.shadowBlur = 0;

          // Reset drop to top with randomness
          if (y > canvas.height && Math.random() > 0.975) {
            drops[i] = 0;
          }
          drops[i]++;
        }
      }

      // Handle window resize for columns
      window.addEventListener("resize", () => {
        columns = Math.floor(canvas.width / fontSize);
        const newDrops = Array(columns).fill(1);
        for (let i = 0; i < newDrops.length; i++) {
          newDrops[i] =
            drops[i] !== undefined ? drops[i] : Math.floor(Math.random() * -50);
        }
        drops = newDrops;
      });

      setInterval(drawMatrix, 45);

      /* ==============================
         ORIGINAL DEBUG FEED LOGIC
         ============================== */
      const logsContainer = document.getElementById("logs");
      const lastUpdateSpan = document.getElementById("last-update");
      let lastJsonString = "";

      marked.setOptions({
        highlight: function (code, lang) {
          const language = hljs.getLanguage(lang) ? lang : "plaintext";
          return hljs.highlight(code, { language }).value;
        },
        breaks: true,
      });

      async function fetchLogs() {
        try {
          const response = await fetch("debug.json?t=" + new Date().getTime());
          if (!response.ok) throw new Error("File not found");

          const rawJson = await response.text();

          if (rawJson !== lastJsonString) {
            lastJsonString = rawJson;
            const data = JSON.parse(rawJson);
            renderLogs(data);
            lastUpdateSpan.innerText = new Date().toLocaleTimeString();
          }
        } catch (err) {
          console.error("Sync error:", err);
          lastUpdateSpan.innerText = "Error loading debug.json";
        }
      }

      /**
       * Try to extract balanced JSON from a string starting at a given position.
       * Returns { json: parsed, endIndex } or null.
       */
      function extractJsonAt(str, startIndex) {
        if (str[startIndex] !== "{" && str[startIndex] !== "'") return null;

        // Skip leading quote if present
        let actualStart = startIndex;
        if (str[actualStart] === "'") actualStart++;
        if (str[actualStart] !== "{") return null;

        let braceCount = 0;
        let jsonEnd = -1;
        for (let i = actualStart; i < str.length; i++) {
          if (str[i] === "{") braceCount++;
          if (str[i] === "}") braceCount--;
          if (braceCount === 0) {
            jsonEnd = i;
            break;
          }
        }
        if (jsonEnd <= actualStart) return null;

        const jsonStr = str.substring(actualStart, jsonEnd + 1);
        try {
          return { json: JSON.parse(jsonStr), endIndex: jsonEnd + 1 };
        } catch (e) {
          return null;
        }
      }

      /**
       * Render system messages (supervisor audits, etc.) with full content preserved.
       * Strategy: split by newlines, classify each segment, render everything.
       */
      function renderSystemMessage(rawContent) {
        // If it doesn't look like a supervisor/audit message, just render as markdown
        const isSupervisorAudit =
          /SUPERVISOR|AUDIT|Forbidden pattern|SYSTEM:\s*Decide/i.test(
            rawContent,
          );
        if (!isSupervisorAudit && !rawContent.includes('"action_type"')) {
          return `<div class="raw-log-content">${marked.parse(rawContent)}</div>`;
        }

        const isRejection =
          /Forbidden pattern|LAZINESS|Replace ALL placeholders|REJECTED/i.test(
            rawContent,
          );
        const auditStatus = isRejection ? "rejected" : "info";

        let html = `<div class="system-audit-wrapper ${auditStatus}">`;

        // We'll walk through the content, pulling out JSON blocks and rendering
        // everything else as styled text segments
        let remaining = rawContent;
        let safety = 0;

        while (remaining.length > 0 && safety < 50) {
          safety++;
          remaining = remaining.trimStart();
          if (!remaining) break;

          // Check if we're at a JSON block
          const jsonStart = remaining.search(/['{]\s*\{?\s*"reasoning"/);

          // --- Audit header line ---
          const auditHeaderMatch = remaining.match(
            /^(ğŸ§\s*SUPERVISOR[^:]*:)\s*/,
          );
          if (auditHeaderMatch) {
            html += `<div class="audit-header">${auditHeaderMatch[1]}</div>`;
            remaining = remaining.substring(auditHeaderMatch[0].length);
            continue;
          }

          // --- "Forbidden pattern" label ---
          const forbiddenMatch = remaining.match(
            /^(Forbidden pattern[^']*?)\s*(?='|\{)/,
          );
          if (forbiddenMatch) {
            html += `<div class="audit-rule">ğŸš« ${forbiddenMatch[1].trim()}</div>`;
            remaining = remaining.substring(forbiddenMatch[0].length);
            continue;
          }

          // --- "Detected Pattern:" label ---
          const detectedMatch = remaining.match(/^Detected Pattern:\s*/i);
          if (detectedMatch) {
            html += `<div class="audit-pattern-label">ğŸ” Detected Pattern</div>`;
            remaining = remaining.substring(detectedMatch[0].length);
            continue;
          }

          // --- "Rule:" line ---
          const ruleMatch = remaining.match(/^Rule:\s*(.*?)(?=\n|ğŸ’»|$)/is);
          if (ruleMatch) {
            html += `<div class="audit-rule">âš ï¸ Rule: ${ruleMatch[1].trim()}</div>`;
            remaining = remaining.substring(ruleMatch[0].length);
            continue;
          }

          // --- "ğŸ’» SYSTEM:" line ---
          const systemMatch = remaining.match(
            /^ğŸ’»\s*SYSTEM:\s*(.*?)(?=\n|Current Time|$)/is,
          );
          if (systemMatch) {
            html += `<div class="system-prompt-line">ğŸ’» SYSTEM: ${systemMatch[1].trim()}</div>`;
            remaining = remaining.substring(systemMatch[0].length);
            continue;
          }

          // --- "Current Time:" line ---
          const timeMatch = remaining.match(/^Current Time:\s*(.*?)(?=\n|$)/i);
          if (timeMatch) {
            html += `<div class="system-time">ğŸ• Current Time: ${timeMatch[1].trim()}</div>`;
            remaining = remaining.substring(timeMatch[0].length);
            continue;
          }

          // --- JSON block (possibly wrapped in quotes) ---
          let jsonResult = null;
          // Try at position 0
          jsonResult = extractJsonAt(remaining, 0);
          if (!jsonResult) {
            // Try skipping a leading quote
            const qIdx = remaining.indexOf("'");
            if (qIdx >= 0 && qIdx < 3) {
              jsonResult = extractJsonAt(remaining, qIdx);
            }
          }
          if (jsonResult) {
            html += `<div class="audit-json-block">`;
            const structured = generateStructuredReport(jsonResult.json);
            if (structured && structured.trim()) {
              html += structured;
            } else {
              html += `<pre><code class="language-json">${JSON.stringify(jsonResult.json, null, 2)}</code></pre>`;
            }
            html += `</div>`;
            // Skip past the JSON and any trailing quote
            remaining = remaining.substring(jsonResult.endIndex);
            if (remaining.startsWith("'")) remaining = remaining.substring(1);
            continue;
          }

          // --- Catch-all: grab text until next recognizable pattern or end ---
          const nextPattern = remaining
            .substring(1)
            .search(
              /ğŸ§|Forbidden pattern|Detected Pattern:|Rule:|ğŸ’»\s*SYSTEM:|Current Time:|['{]\s*\{?\s*"reasoning"/i,
            );

          if (nextPattern >= 0) {
            const chunk = remaining.substring(0, nextPattern + 1).trim();
            if (chunk) {
              html += `<div class="audit-text">${marked.parse(chunk)}</div>`;
            }
            remaining = remaining.substring(nextPattern + 1);
          } else {
            // Nothing else matched â€” render the rest
            html += `<div class="audit-text">${marked.parse(remaining)}</div>`;
            remaining = "";
          }
        }

        html += `</div>`;
        return html;
      }

      function renderLogs(messages) {
        logsContainer.innerHTML = "";
        messages.forEach((msg, index) => {
          const card = document.createElement("div");
          card.className = "message-card";
          const roleClass = `role-${msg.role}`;

          let rawContent = msg.content.trim();
          let htmlContent = "";

          if (msg.role === "assistant" && rawContent.startsWith("{")) {
            try {
              const data = JSON.parse(rawContent);
              htmlContent = generateStructuredReport(data, msg.attempts_left);
            } catch (e) {
              htmlContent = `<pre><code class="language-json">${rawContent}</code></pre>`;
            }
          } else if (
            msg.role === "system" ||
            (rawContent.includes('"action_type"') &&
              rawContent.includes("SUPERVISOR"))
          ) {
            htmlContent = renderSystemMessage(rawContent);
          } else {
            htmlContent = `<div class="raw-log-content">${marked.parse(rawContent)}</div>`;
          }

          card.innerHTML = `
            <div class="role-badge ${roleClass}">
                <span>${msg.role.toUpperCase()} #${index + 1}</span>
            </div>
            <div class="content">${htmlContent}</div>
        `;
          logsContainer.appendChild(card);
        });

        document
          .querySelectorAll("pre code")
          .forEach((el) => hljs.highlightElement(el));
        window.scrollTo(0, document.body.scrollHeight);
      }

      function renderTodoList(tasks, reasoning) {
        let listItems = tasks
          .map((t) => {
            const stars = "â­".repeat(t.priority || 1);
            return `<div class="todo-item-row" style="padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.1); font-family: monospace;">
              <span style="color: #d29922;">[${stars}]</span> ${t.task}
            </div>`;
          })
          .join("");

        return `
    <div class="planning-box">
      <p style="font-style: italic; color: #8b949e; margin-bottom: 10px;">${reasoning || ""}</p>
      <h4 style="color: #58a6ff; margin: 0 0 10px 0;">ğŸš€ SESSION ROADMAP</h4>
      ${listItems}
    </div>
  `;
      }

      function generateStructuredReport(data, attemptsLeft) {
        let sections = [];

        if (data.tasks && Array.isArray(data.tasks)) {
          let listItems = data.tasks
            .map((t) => {
              const stars = "â­".repeat(t.priority || 1);
              return `<div class="todo-item-row" style="padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.1); font-family: monospace;">
                      <span style="color: #d29922;">[${stars}]</span> ${t.task}
                    </div>`;
            })
            .join("");

          return `
            <div class="planning-box">
                ${data.reasoning ? `<p style="font-style: italic; color: #8b949e; margin-bottom: 10px;">${data.reasoning}</p>` : ""}
                <h4 style="color: #58a6ff; margin: 0 0 10px 0;">ğŸš€ SESSION ROADMAP</h4>
                ${listItems}
            </div>
        `;
        }

        if (data.emotions || data.feelings) {
          sections.push(`
            <div class="sentience-container">
                ${data.emotions ? `<div class="emotion-tag"><strong>ğŸ­ Emotion:</strong> ${data.emotions}</div>` : ""}
                ${data.feelings ? `<div class="feeling-tag"><strong>ğŸ’“ Feeling:</strong> ${data.feelings}</div>` : ""}
            </div>
        `);
        }

        if (data.reasoning || data.self_criticism) {
          sections.push(`
            <div class="report-section meta">
                ${data.reasoning ? `<div class="thought-box"><strong>ğŸ§  Reasoning:</strong><br>${marked.parse(data.reasoning)}</div>` : ""}
                ${data.self_criticism ? `<div class="audit-box"><strong>ğŸ›¡ï¸ Self-Criticism:</strong><br>${marked.parse(data.self_criticism)}</div>` : ""}
            </div>
        `);
        }

        if (data.action_type) {
          sections.push(`
            <div class="report-section action">
                <h3 style="color: #d1d5da; font-size: 0.8em; margin-bottom: 8px;">âš¡ ACTION: ${data.action_type.toUpperCase()}</h3>
                <div class="params-box">
                    <pre><code class="language-json">${JSON.stringify(data.action_params, null, 2)}</code></pre>
                </div>
            </div>
        `);
        }

        if (data.validate !== undefined) {
          const statusClass = data.validate ? "valid" : "invalid";
          sections.push(`
            <div class="supervisor-box ${statusClass}">
                <h3 style="margin:0">ğŸ§ Supervisor Audit: ${data.validate ? "PASSED âœ…" : "REJECTED âŒ"}</h3>
                <div class="feedback-msg" style="margin-top:10px;">ğŸ’¬ Message: ${data.message_for_agent}</div>
            </div>
        `);
        }

        if (data.next_move_preview) {
          sections.push(`
            <p class="next-move" style="margin-top:10px; border-top: 1px solid #30363d; padding-top:10px;">
                ğŸ”­ <strong>Next Move:</strong> ${data.next_move_preview}
            </p>
        `);
        }

        return sections.join("");
      }

      setInterval(fetchLogs, 2000);
      fetchLogs();
    </script>
  </body>
</html>
